/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Formatted elements (zlib license) provided for TGUI - Texus' Graphical User Interface
// Copyright (C) 2023 Steffen Ploetz (Steffen.Ploetz@cityweb.de)
//
// This software is provided 'as-is', without any express or implied warranty.
// In no event will the authors be held liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it freely,
// subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented;
//    you must not claim that you wrote the original software.
//    If you use this software in a product, an acknowledgment
//    in the product documentation would be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such,
//    and must not be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef TGUI_FORMATTED_ELEMENTS_HPP
#define TGUI_FORMATTED_ELEMENTS_HPP


#include "TGUI/Xhtml/MarkupSizeType.hpp"
#include "TGUI/Xhtml/MarkupBorderStyle.hpp"
#include "TGUI/Xhtml/MarkupLanguageElement.hpp"

namespace tgui  { namespace xhtml
{

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The virtual base class for **all** formatted element classes
    ///
    /// Formatted elements are used to abstract XHTML, markdown, RTF, ... formatting, and hold the formatting information
    /// that are needed to be displayed by the FormattedTextView widget
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedElement
    {
    public:
        using Ptr = std::shared_ptr<FormattedElement>;            //!< Shared formatted element pointer
        using ConstPtr = std::shared_ptr<const FormattedElement>; //!< Shared constant formatted element pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedElement()
            : m_contentOrigin(nullptr), m_layoutArea(FloatRect(0.0f, 0.0f, 0.0f, 0.0f)), m_layoutRefLine(0.0f),
              m_backgroundColor(Color(255, 255, 255)), m_opacity(1.0f)
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The virtual default destructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual ~FormattedElement()
        { ; }


    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the content origin data element, that is to be (partly) represented by this formatted element
        ///
        /// @param origin  The new content origin data element to set
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setContentOrigin(MarkupLanguageElement::Ptr origin)
        {   m_contentOrigin = origin;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the origin data element, that is (partly) represented by this formatted element
        ///
        /// @return The origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline MarkupLanguageElement::Ptr getContentOrigin() const
        {   return m_contentOrigin;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the origin data element ID or an empty string
        ///
        /// @return The origin data element ID on success or an empty string otherwise
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline const tgui::String& getOriginId() const
        {   if (m_contentOrigin != nullptr) return m_contentOrigin->getId(); else return MarkupLanguageElement::getEmptyString();   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the origin data element name or an empty string
        ///
        /// @return The origin data element name on success or an empty string otherwise
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline const tgui::String& getOriginName() const
        {   if (m_contentOrigin != nullptr) return m_contentOrigin->getName(); else return MarkupLanguageElement::getEmptyString();   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the layout area (within the widget, it wil be rendered) of this formatted element (to an empty area by default)
        ///
        /// @param position  The new (empty) layout area position
        /// @param size      The new (empty) layout area size (default is {0, 0})
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayoutArea(Vector2f position, Vector2f size = {0.0f, 0.0f})
        {
            m_layoutArea.left = position.x;
            m_layoutArea.width = size.x;
            m_layoutArea.top = position.y;
            m_layoutArea.height = size.y;
            m_layoutRefLine = m_layoutArea.top + m_layoutArea.height;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area of this formatted element (within the widget, it wil be rendered)
        ///
        /// @return The layout area of this formatted element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FloatRect getLayoutArea() const
        {   return m_layoutArea;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area (within the widget, it wil be rendered) reference line (y position)
        ///
        /// @return The layout area reference line (y position)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getLayoutRefLine() const
        {   return m_layoutRefLine;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new layout area (within the widget, it wil be rendered) top left position (without affecting the size)
        ///
        /// @param position        The new layout area top left position
        /// @param indentOffset    The horizontal indent offset. Default is 0.0f
        /// @param subsciptOffset  The vertical subscipt offset. Default is 0.0f
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayoutLeftTop(Vector2f position, float indentOffset = 0.0f, float subsciptOffset = 0.0f)
        {
            m_layoutRefLine = position.y - m_layoutArea.top;
            m_layoutArea.left = position.x + indentOffset;
            m_layoutArea.top = position.y + subsciptOffset;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new layout area (within the widget, it wil be rendered) left position (without affecting the size)
        ///
        /// @param left  The new layout area left position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayoutLeft(float left)
        {   m_layoutArea.left = left;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new layout area (within the widget, it wil be rendered) top position (without affecting the size)
        ///
        /// @param position        The new layout area top position
        /// @param indentOffset    The horizontal indent offset. Default is 0.0f
        /// @param subsciptOffset  The vertical subscipt offset. Default is 0.0f
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayoutTop(float top)
        {
            m_layoutRefLine = top - m_layoutArea.top;
            m_layoutArea.top = top;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area top (within the widget, it wil be rendered) left position of this formatted element
        ///
        /// @return The layout area top left position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2f getLayoutLeftTop() const
        {   return {m_layoutArea.left, m_layoutArea.top};   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area (within the widget, it wil be rendered) left position of this formatted element
        ///
        /// @return The layout area left position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getLayoutLeft() const
        {   return m_layoutArea.left;  }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area (within the widget, it wil be rendered) top position of this formatted element
        ///
        /// @return The layout area top position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        float getLayoutTop() const
        {   return m_layoutArea.top;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the layout area (within the widget, it wil be rendered) size (without affecting the top left coordinates) of this formatted element
        ///
        /// @param size  The new layout area size to set (the size is relative to the top left coordinates)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayouSize(Vector2f size)
        {
            m_layoutRefLine += size.y - m_layoutArea.height;
            m_layoutArea.width = size.x;
            m_layoutArea.height = size.y;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area (within the widget, it wil be rendered) size of this formatted element
        ///
        /// @return The layout area size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2f getLayoutSize() const
        {   return {m_layoutArea.width, m_layoutArea.height};   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the layout area (within the widget, it wil be rendered) bottom right coordinates (with affecting the size) of this formatted element
        ///
        /// @param bottomRight        The new layout area bottom right coordinates (absolute coordinates)
        /// @param indentOffset       The horizontal indent offset. Default is 0.0f
        /// @param superscriptOffset  The vertical superscipt offset. Default is 0.0f
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayoutRightBottom(Vector2f bottomRight, float indentOffset = 0.0f, float superscriptOffset = 0.0f)
        {
            m_layoutRefLine = bottomRight.y;
            m_layoutArea.width = bottomRight.x + indentOffset - m_layoutArea.left;
            m_layoutArea.height = bottomRight.y + superscriptOffset - m_layoutArea.top;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the layout area (within the widget, it wil be rendered) right coordinate (with affecting the size) of this formatted element
        ///
        /// @param right  The new layout area right coordinate (absolute coordinates)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayoutRight(float right)
        {   m_layoutArea.width = right - m_layoutArea.left;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area (within the widget, it wil be rendered) right position of this formatted element
        ///
        /// @return The layout area right position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getLayoutRight() const
        {   return m_layoutArea.left + m_layoutArea.width;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the layout area (within the widget, it wil be rendered) bottom coordinate (with affecting the size) of this formatted element
        ///
        /// @param bottom  The new layout area bottom coordinate (absolute coordinates)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLayoutBottom(float bottom)
        {
            m_layoutRefLine = bottom;
            m_layoutArea.height = bottom - m_layoutArea.top;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the layout area (within the widget, it wil be rendered) bottom position of this formatted element
        ///
        /// @return The layout area bottom position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        float getLayoutBottom() const
        {   return m_layoutArea.top + m_layoutArea.height;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new background color of this rect section
        ///
        /// @param backgroundColor  The new background color of this rect section
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setBackgroundColor(Color backgroundColor)
        {   m_backgroundColor = backgroundColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the background color of this rect section
        ///
        /// @return The background color of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getBackgroundColor() const
        {   return m_backgroundColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new background opacity of this rect section
        ///
        /// @param opacity  The new opacity of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setOpacity(float opacity)
        {   m_opacity = opacity;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the background opacity of this rect section
        ///
        /// @return The background opacity of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getOpacity() const
        {   return m_opacity;   }

    protected:
        MarkupLanguageElement::Ptr m_contentOrigin;   //!< The origin data element, that is (partly) represented by this formatted element
        FloatRect                  m_layoutArea;      //!< The layout area (within the widget, it wil be rendered)
        float                      m_layoutRefLine;   //!< The layout area (within the widget, it wil be rendered) reference line (y position)
        Color                      m_backgroundColor; //!< The background color
        float                      m_opacity;         //!< The background opacity
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted rectangle
    ///
    /// This class represents a rectangle area that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedRectangle : public FormattedElement
    {
    public:
        using Ptr = std::shared_ptr<FormattedRectangle>;            //!< Shared formatted rectangle area pointer
        using ConstPtr = std::shared_ptr<const FormattedRectangle>; //!< Shared formatted rectangle area pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedRectangle()
            : FormattedElement(), m_margin(SizeType::Pixel, 0.0f), m_borderWidth(SizeType::Pixel, 0.0f), m_borderColor(Color(0, 0, 0))
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the area margin (should always be in px)
        ///
        /// @param boderMargin  The new area margin (should always be in px)
        ///
        /// @return             A reference to this formatted rectangle
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FormattedRectangle& setMargin(FourDimSize margin)
        {   m_margin = margin; return *this;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the area margin (should always be in px)
        ///
        /// @return The area margin (should always be in px)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FourDimSize getMargin() const
        {    return m_margin;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the area border style
        ///
        /// @param borderStyle  The new area border style
        ///
        /// @return             A reference to this formatted rectangle
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FormattedRectangle& setBoderStyle(const FourDimBorderStyle& borderStyle)
        {   m_borderStyle = borderStyle; return *this;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the area border style
        ///
        /// @return The area border width
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FourDimBorderStyle getBoderStyle() const
        {    return m_borderStyle;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the area border width (should always be in px)
        ///
        /// @param borderWidth  The new area border width (should always be in px)
        ///
        /// @return             A reference to this formatted rectangle
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FormattedRectangle& setBoderWidth(const FourDimSize& borderWidth)
        {   m_borderWidth = borderWidth; return *this;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the area border width (should always be in px)
        ///
        /// @return The area border width (should always be in px)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FourDimSize getBoderWidth() const
        {   return m_borderWidth;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new border color of this rect section
        ///
        /// @param borderColor  The new border color of this rect section
        ///
        /// @return             A reference to this formatted rectangle
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FormattedRectangle& setBorderColor(Color borderColor)
        {   m_borderColor = borderColor; return *this;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the border color of this rect section
        ///
        /// @return The border color of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getBorderColor() const
        {   return m_borderColor;   }

    protected:
        FourDimSize        m_margin;              //!< The margin (should always be in px)
        FourDimBorderStyle m_borderStyle;         //!< The border style
        FourDimSize        m_borderWidth;         //!< The border width (should always be in px)
        Color              m_borderColor;         //!< The border color
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted link area
    ///
    /// This class represents an link area that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedLink : public FormattedRectangle
    {
    public:
        using Ptr = std::shared_ptr<FormattedLink>;            //!< Shared formatted link area pointer
        using ConstPtr = std::shared_ptr<const FormattedLink>; //!< Shared formatted link area pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedLink()
            : FormattedRectangle(), m_href(U""), m_linkColor(Color(U"#4500AD")), m_activeColor(Color(U"#4500AD")),
              m_visitedColor(Color(U"#100080")), m_underlined(true), m_visited(false), m_active(false)
        {   ;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the link target
        ///
        /// @param href  The link target
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setHref(String href)
        {   m_href = href;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the link target
        ///
        /// @return The link target
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline String getHref() const
        {   return m_href;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the color an unvisited link
        ///
        /// @param linkColor  The color an unvisited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLinkColor(Color linkColor)
        {   m_linkColor = linkColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the color an unvisited link
        ///
        /// @return The color an unvisited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getLinkColor() const
        {   return m_linkColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the color an active link
        ///
        /// @param activeColor  The color an active link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setActiveColor(Color activeColor)
        {   m_activeColor = activeColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the color an active link
        ///
        /// @return  The color an active link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getActiveColor() const
        {   return m_activeColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the color an visited link
        ///
        /// @param visitedColor  The color an visited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setVisitedColor(Color visitedColor)
        {   m_visitedColor = visitedColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the color an visited link
        ///
        /// @return  The color an visited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getVisitedColor() const
        {   return m_visitedColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the flag that determines whether to underline on hover/mouseover
        ///
        /// @param underlined  The flag that determines whether to underline on hover/mouseover
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setUnderlined(bool underlined)
        {   m_underlined = underlined;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the flag that determines whether to underline on hover/mouseover
        ///
        /// @return The flag that determines whether to underline on hover/mouseover
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline bool getUnderlined() const
        {   return m_underlined;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the flag that determines whether this link has been visited
        ///
        /// @param visited  The flag that determines whether this link has been visited
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setVisited(bool visited)
        {   m_visited = visited;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the flag that determines whether this link has been visited
        ///
        /// @return The flag that determines whether this link has been visited
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline bool getVisited() const
        {   return m_visited;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the flag that determines whether this link is currently active
        ///
        /// @param active  The flag that determines whether this link is currently active
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setActive(bool active)
        {   m_active = active;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the flag that determines whether this link is currently active
        ///
        /// @return The flag that determines whether this linkis currently active
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline bool getActive() const
        {   return m_active;   }

    protected:
        String            m_href;                  //!< The link target
        Color             m_linkColor;             //!< The color an unvisited link
        Color             m_activeColor;           //!< The color an active link
        Color             m_visitedColor;          //!< The color an visited link
        bool              m_underlined;            //!< The flag that determines whether to underline
        bool              m_visited;               //!< The flag that determines whether this link has been visited
        bool              m_active;                //!< The flag that determines whether this link is currently active
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted image
    ///
    /// This class represents an image that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedImage : public FormattedRectangle
    {
    public:
        using Ptr = std::shared_ptr<FormattedImage>;            //!< Shared formatted image pointer
        using ConstPtr = std::shared_ptr<const FormattedImage>; //!< Shared formatted image pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedImage()
            : FormattedRectangle(), m_texture(), m_altText(), m_physicalSize(), m_logicalSize()
        {   ;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the texture of the image
        ///
        /// @param string  The texture of the image
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setTexture(const Texture& texture)
        {   m_texture = texture;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the texture of the image
        ///
        /// @return The texture of the image
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Texture& getTexture()
        {   return m_texture;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the texture's physical size
        ///
        /// @param string  The texture's physical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setPhysicalSize(Vector2u size)
        {   m_physicalSize = size;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the texture's physical size
        ///
        /// @return  The texture's physical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2u getPhysicalSize()
        {   return m_physicalSize;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the texture's logical size
        ///
        /// @param string  The texture's logical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLogicalSize(Vector2u size)
        {   m_logicalSize = size;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the texture's logical size
        ///
        /// @return  The texture's logical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2u getLogicaSize()
        {   return m_logicalSize;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the alternative text
        ///
        /// @param string  The alternative text
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setAltText(const String& string)
        {   m_altText = string;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the alternative text
        ///
        /// @return The alternative text
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline String& getAltText()
        {   return m_altText;   }

    protected:
        Texture           m_texture;               //!< The texture of the image
        String            m_altText;               //!< The alternative text
        Vector2u          m_physicalSize;          //!< The texture's physical size
        Vector2u          m_logicalSize;           //!< The texture's logical size
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted text section
    ///
    /// This class represents a text piece that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedTextSection : public FormattedElement
    {
    public:
        using Ptr = std::shared_ptr<FormattedTextSection>;            //!< Shared formatted text section pointer
        using ConstPtr = std::shared_ptr<const FormattedTextSection>; //!< Shared formatted text section pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedTextSection(const Color& foreColor)
            : FormattedElement(), m_startInContentOrigin(0), m_lengthInContentOrigin(0), m_color(foreColor),
              m_font(), m_string(), m_style(TextStyle::Regular)
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The initializing constructor
        ///
        /// @param style  The text style
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedTextSection(const Color& foreColor, TextStyle style)
            : FormattedElement(), m_startInContentOrigin(0), m_lengthInContentOrigin(0),  m_color(foreColor),
              m_font(), m_string(), m_style(style)
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The virtual default destructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual ~FormattedTextSection()
        { ; }


    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Creates a new formatted text section
        ///
        /// Prefer the factory method in cases where the formatted text section needs to be shared, otherwise prefer the constructor.
        /// Also prefer the factory method in cases where mutual references between owner and owned are required, bacause
        /// sing shared_from_this() without previous call to make_shared() (like in a constructor) leads to undefined results.
        ///
        /// @param textStyle  The text style
        ///
        /// @return The new formatted text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        static inline FormattedTextSection::Ptr create(const Color& foreColor, TextStyle textStyle)
        { return std::make_shared<FormattedTextSection>(foreColor, textStyle); }


    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the text start position within the content origin data element, that is represented by this text element
        ///
        /// @param startInContentOrigin  The new text start position within the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setStartInContentOrigin(size_t startInContentOrigin)
        { m_startInContentOrigin = startInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text start position within the content origin data element, that is represented by this text element
        ///
        /// @return The text start position within the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t getStartInContentOrigin() const
        { return m_startInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the text length within the content origin data element, that is represented by this text element
        ///
        /// @param lengthInContentOrigin  The new text length within the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLengthInContentOrigin(size_t lengthInContentOrigin)
        { m_lengthInContentOrigin = lengthInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text length within the content origin data element, that is represented by this text element
        ///
        /// @return The text length the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t getLengthInContentOrigin() const
        { return m_lengthInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new text color of this text section
        ///
        /// @param color  The new text color of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setColor(Color color)
        { m_color = color; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text color of this text section
        ///
        /// @return The text color of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getColor() const
        { return m_color; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new character size of this text section
        ///
        /// @param height  The new character size of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderHeight(float height)
        { m_layoutArea.height = height; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the character size of this text section
        ///
        /// @return The character size of this text section. Default is 16
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        unsigned int getCharacterSizeAsInt() const
        { return static_cast<unsigned int>(m_layoutArea.height + 0.49f); }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new run length of this text section
        ///
        /// @param runLength  The new run length of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRunLength(float runLength)
        { m_layoutArea.width = runLength; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the run length of this text section
        ///
        /// @return The run length of this text section. Default is 16
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getRunLength() const
        { return m_layoutArea.width; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new font of this text section
        ///
        /// @param font  The new font of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setFont(const Font& font)
        { m_font = font; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the font of this text section
        ///
        /// @return The font of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Font& getFont() { return m_font; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new text of this text section
        ///
        /// @param string  The new text of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setString(const String& string)
        { m_string = string; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text of this text section
        ///
        /// @return The text of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline String& getString()
        { return m_string; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new text style of this text section
        ///
        /// The possible styles can be found in the tgui::TextStyle::Style enum.
        /// You can also pass a combination of multiple styles, for example tgui::TextStyle::Bold | tgui::TextStyle::Italic.
        /// The default style is tgui::TextStyle::Regular.
        ///
        /// @param style  The new text style of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setStyle(TextStyle style)
        { m_style = style; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text style of this text section
        ///
        /// @return The text style of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline TextStyle getStyle() const
        { return m_style; }

    protected:
        size_t            m_startInContentOrigin;  //!< The text start position within the content origin data element
        size_t            m_lengthInContentOrigin; //!< The text length within the content origin data element
        Color             m_color;                 //!< The text color
        Font              m_font;                  //!< The text font
        String            m_string;                //!< The text string
        TextStyle         m_style;                 //!< The text style
    };
} }

#endif // TGUI_FORMATTED_ELEMENTS_HPP
