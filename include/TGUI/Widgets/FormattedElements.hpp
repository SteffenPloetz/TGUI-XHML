/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Formatted elements (zlib license) provided for TGUI - Texus' Graphical User Interface
// Copyright (C) 2023 Steffen Ploetz (Steffen.Ploetz@cityweb.de)
//
// This software is provided 'as-is', without any express or implied warranty.
// In no event will the authors be held liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it freely,
// subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented;
//    you must not claim that you wrote the original software.
//    If you use this software in a product, an acknowledgment
//    in the product documentation would be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such,
//    and must not be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef TGUI_FORMATTED_ELEMENTS_HPP
#define TGUI_FORMATTED_ELEMENTS_HPP

#include "TGUI/MarkupLanguageElement.hpp"

namespace tgui
{

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The virtual base class for **all** formatted element classes
    ///
    /// Formatted elements are used to abstract XHTML, markdown, RTF, ... formatting, and hold the formatting information
    /// that are needed to be displayed by the FormattedTextView widget
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedElement
    {
    public:
        using Ptr = std::shared_ptr<FormattedElement>;            //!< Shared formatted element pointer
        using ConstPtr = std::shared_ptr<const FormattedElement>; //!< Shared constant formatted element pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedElement()
            : m_contentOrigin(nullptr), m_renderArea(FloatRect(0.0f, 0.0f, 0.0f, 0.0f)), m_renderRefLine(0.0f),
              m_backgroundColor(Color(255, 255, 255)), m_opacity(1.0f)
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The virtual default destructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual ~FormattedElement()
        { ; }


    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the content origin data element, that is to be (partly) represented by this formatted element
        ///
        /// @param origin  The new content origin data element to set
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setContentOrigin(MarkupLanguageElement::Ptr origin)
        {   m_contentOrigin = origin;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the origin data element, that is (partly) represented by this formatted element
        ///
        /// @return The origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline MarkupLanguageElement::Ptr getContentOrigin() const
        {   return m_contentOrigin;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the origin data element ID or an empty string
        ///
        /// @return The origin data element ID on success or an empty string otherwise
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline const tgui::String& getOriginId() const
        {   if (m_contentOrigin != nullptr) return m_contentOrigin->getId(); else return MarkupLanguageElement::getEmptyString();   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the origin data element name or an empty string
        ///
        /// @return The origin data element name on success or an empty string otherwise
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline const tgui::String& getOriginName() const
        {   if (m_contentOrigin != nullptr) return m_contentOrigin->getName(); else return MarkupLanguageElement::getEmptyString();   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the render area (to an empty area at indicated position) of this formatted element
        ///
        /// @param position  The new (empty) render area position
        /// @param size      The new (empty) render area size (default is {0, 0})
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderArea(Vector2f position, Vector2f size = {0.0f, 0.0f})
        {
            m_renderArea.left = position.x;
            m_renderArea.width = size.x;
            m_renderArea.top = position.y;
            m_renderArea.height = size.y;
            m_renderRefLine = m_renderArea.top + m_renderArea.height;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area of this formatted element
        ///
        /// @return The render area of this formatted element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FloatRect getRenderArea() const
        {   return m_renderArea;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area reference line (y position)
        ///
        /// @return The render area reference line (y position)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getRenderRefLine() const
        {   return m_renderRefLine;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new render area top left position (without affecting the size)
        ///
        /// @param position        The new render area top left position
        /// @param indentOffset    The horizontal indent offset. Default is 0.0f
        /// @param subsciptOffset  The vertical subscipt offset. Default is 0.0f
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderLeftTop(Vector2f position, float indentOffset = 0.0f, float subsciptOffset = 0.0f)
        {
            m_renderRefLine = position.y - m_renderArea.top;
            m_renderArea.left = position.x + indentOffset;
            m_renderArea.top = position.y + subsciptOffset;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new render area left position (without affecting the size)
        ///
        /// @param left  The new render area left position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderLeft(float left)
        {   m_renderArea.left = left;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new render area top position (without affecting the size)
        ///
        /// @param position        The new render area top position
        /// @param indentOffset    The horizontal indent offset. Default is 0.0f
        /// @param subsciptOffset  The vertical subscipt offset. Default is 0.0f
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderTop(float top)
        {
            m_renderRefLine = top - m_renderArea.top;
            m_renderArea.top = top;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area top left position of this formatted element
        ///
        /// @return The render area top left position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2f getRenderLeftTop()
        {   return {m_renderArea.left, m_renderArea.top};   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area left position of this formatted element
        ///
        /// @return The render area left position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getRenderLeft() const
        {   return m_renderArea.left;  }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area top position of this formatted element
        ///
        /// @return The render area top position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        float getRenderTop() const
        {   return m_renderArea.top;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the render area size (without affecting the top left coordinates) of this formatted element
        ///
        /// @param size  The new render area size to set (the size is relative to the top left coordinates)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderSize(Vector2f size)
        {
            m_renderRefLine += size.y - m_renderArea.height;
            m_renderArea.width = size.x;
            m_renderArea.height = size.y;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area size of this formatted element
        ///
        /// @return The render area size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2f getRenderSize()
        {   return {m_renderArea.width, m_renderArea.height};   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the render area bottom right coordinates (with affecting the size) of this formatted element
        ///
        /// @param bottomRight        The new render area bottom right coordinates (absolute coordinates)
        /// @param indentOffset       The horizontal indent offset. Default is 0.0f
        /// @param superscriptOffset  The vertical superscipt offset. Default is 0.0f
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderRightBottom(Vector2f bottomRight, float indentOffset = 0.0f, float superscriptOffset = 0.0f)
        {
            m_renderRefLine = bottomRight.y;
            m_renderArea.width = bottomRight.x + indentOffset - m_renderArea.left;
            m_renderArea.height = bottomRight.y + superscriptOffset - m_renderArea.top;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the render area right coordinate (with affecting the size) of this formatted element
        ///
        /// @param right  The new render area right coordinate (absolute coordinates)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderRight(float right)
        {   m_renderArea.width = right - m_renderArea.left;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area right position of this formatted element
        ///
        /// @return The render area right position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getRenderRight() const
        {   return m_renderArea.left + m_renderArea.width;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the render area bottom coordinate (with affecting the size) of this formatted element
        ///
        /// @param bottom  The new render area bottom coordinate (absolute coordinates)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderBottom(float bottom)
        {
            m_renderRefLine = bottom - (m_renderArea.top + m_renderArea.height);
            m_renderArea.height = bottom - m_renderArea.top;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area bottom position of this formatted element
        ///
        /// @return The render area bottom position
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        float getRenderBottom() const
        {   return m_renderArea.top + m_renderArea.height;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new background color of this rect section
        ///
        /// @param backgroundColor  The new background color of this rect section
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setBackgroundColor(Color backgroundColor)
        {   m_backgroundColor = backgroundColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the background color of this rect section
        ///
        /// @return The background color of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getBackgroundColor() const
        {   return m_backgroundColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new background opacity of this rect section
        ///
        /// @param opacity  The new opacity of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setOpacity(float opacity)
        {   m_opacity = opacity;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the background opacity of this rect section
        ///
        /// @return The background opacity of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getOpacity() const
        {   return m_opacity;   }

    protected:
        MarkupLanguageElement::Ptr m_contentOrigin;   //!< The origin data element, that is (partly) represented by this formatted element
        FloatRect                  m_renderArea;      //!< The render area
        float                      m_renderRefLine;   //!< The render area reference line (y position)
        Color                      m_backgroundColor; //!< The background color
        float                      m_opacity;         //!< The background opacity
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted rectangle
    ///
    /// This class represents a rectangle area that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedRectangle : public FormattedElement
    {
    public:
        using Ptr = std::shared_ptr<FormattedRectangle>;            //!< Shared formatted rectangle area pointer
        using ConstPtr = std::shared_ptr<const FormattedRectangle>; //!< Shared formatted rectangle area pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedRectangle()
            : FormattedElement(), m_borderWidth(SizeType::Pixel, 0.0f), m_borderColor(Color(0, 0, 0))
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the render area border width
        ///
        /// @param size  The new render area border width
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setBoderWidth(const FourDimSize& borderWidth)
        { m_borderWidth = borderWidth; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the render area border width
        ///
        /// @return The render area border width
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline FourDimSize getBoderWidth() const
        { return m_borderWidth; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new border color of this rect section
        ///
        /// @param borderColor  The new border color of this rect section
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setBorderColor(Color borderColor)
        { m_borderColor = borderColor; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the border color of this rect section
        ///
        /// @return The border color of this rect section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getBorderColor() const
        { return m_borderColor; }

    protected:
        FourDimSize       m_borderWidth;         //!< The border width
        Color             m_borderColor;         //!< The border color
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted link area
    ///
    /// This class represents an link area that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedLink : public FormattedRectangle
    {
    public:
        using Ptr = std::shared_ptr<FormattedLink>;            //!< Shared formatted link area pointer
        using ConstPtr = std::shared_ptr<const FormattedLink>; //!< Shared formatted link area pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedLink()
            : FormattedRectangle(), m_href(U""), m_linkColor(Color(U"#4500AD")), m_activeColor(Color(U"#600090")),
              m_visitedColor(Color(U"#100080")), m_underlined(true), m_visited(false)
        {   ;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the link target
        ///
        /// @param href  The link target
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setHref(String href)
        {   m_href = href;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the link target
        ///
        /// @return The link target
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline String getHref()
        {   return m_href;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the color an unvisited link
        ///
        /// @param linkColor  The color an unvisited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLinkColor(Color linkColor)
        {   m_linkColor = linkColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the color an unvisited link
        ///
        /// @return The color an unvisited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getLinkColor()
        {   return m_linkColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the color an active link
        ///
        /// @param activeColor  The color an active link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setActiveColor(Color activeColor)
        {   m_activeColor = activeColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the color an active link
        ///
        /// @return  The color an active link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getActiveColor()
        {   return m_activeColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the color an visited link
        ///
        /// @param visitedColor  The color an visited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setVisitedColor(Color visitedColor)
        {   m_visitedColor = visitedColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the color an visited link
        ///
        /// @return  The color an visited link
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getVisitedColor()
        {   return m_visitedColor;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the flag that determines whether to underline
        ///
        /// @param underlined  The flag that determines whether to underline
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setUnderlined(bool underlined)
        {   m_underlined = underlined;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the flag that determines whether to underline
        ///
        /// @return The flag that determines whether to underline
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline bool getUnderlined()
        {   return m_underlined;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the flag that determines whether this link has been visited
        ///
        /// @param visited  The flag that determines whether this link has been visited
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setVisited(bool visited)
        {   m_visited = visited;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the flag that determines whether this link has been visited
        ///
        /// @return The flag that determines whether this link has been visited
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline bool getVisited()
        {   return m_visited;   }

    protected:
        String            m_href;                  //!< The link target
        Color             m_linkColor;             //!< The color an unvisited link
        Color             m_activeColor;           //!< The color an active link
        Color             m_visitedColor;          //!< The color an visited link
        bool              m_underlined;            //!< The flag that determines whether to underline
        bool              m_visited;               //!< The flag that determines whether this link has been visited
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted image
    ///
    /// This class represents an image that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedImage : public FormattedRectangle
    {
    public:
        using Ptr = std::shared_ptr<FormattedImage>;            //!< Shared formatted image pointer
        using ConstPtr = std::shared_ptr<const FormattedImage>; //!< Shared formatted image pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedImage()
            : FormattedRectangle(), m_texture(), m_altText(), m_physicalSize(), m_logicalSize()
        {   ;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the texture of the image
        ///
        /// @param string  The texture of the image
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setTexture(const Texture& texture)
        {   m_texture = texture;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the texture of the image
        ///
        /// @return The texture of the image
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Texture& getTexture()
        {   return m_texture;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the texture's physical size
        ///
        /// @param string  The texture's physical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setPhysicalSize(Vector2u size)
        {   m_physicalSize = size;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the texture's physical size
        ///
        /// @return  The texture's physical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2u getPhysicalSize()
        {   return m_physicalSize;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the texture's logical size
        ///
        /// @param string  The texture's logical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLogicalSize(Vector2u size)
        {   m_logicalSize = size;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the texture's logical size
        ///
        /// @return  The texture's logical size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Vector2u getLogicaSize()
        {   return m_logicalSize;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the alternative text
        ///
        /// @param string  The alternative text
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setAltText(const String& string)
        {   m_altText = string;   }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the alternative text
        ///
        /// @return The alternative text
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline String& getAltText()
        {   return m_altText;   }

    protected:
        Texture           m_texture;               //!< The texture of the image
        String            m_altText;               //!< The alternative text
        Vector2u          m_physicalSize;          //!< The texture's physical size
        Vector2u          m_logicalSize;           //!< The texture's logical size
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief The formatted text section
    ///
    /// This class represents a text piece that is uniquely formatted
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API FormattedTextSection : public FormattedElement
    {
    public:
        using Ptr = std::shared_ptr<FormattedTextSection>;            //!< Shared formatted text section pointer
        using ConstPtr = std::shared_ptr<const FormattedTextSection>; //!< Shared formatted text section pointer

    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The default constructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedTextSection(const Color& foreColor)
            : FormattedElement(), m_startInContentOrigin(0), m_lengthInContentOrigin(0), m_color(foreColor),
              m_font(), m_string(), m_style(TextStyle::Regular)
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The initializing constructor
        ///
        /// @param style  The text style
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FormattedTextSection(const Color& foreColor, TextStyle style)
            : FormattedElement(), m_startInContentOrigin(0), m_lengthInContentOrigin(0),  m_color(foreColor),
              m_font(), m_string(), m_style(style)
        { ; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief The virtual default destructor
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        virtual ~FormattedTextSection()
        { ; }


    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Creates a new formatted text section
        ///
        /// Prefer the factory method in cases where the formatted text section needs to be shared, otherwise prefer the constructor.
        ///
        /// @param textStyle  The text style
        ///
        /// @return The new formatted text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        static inline FormattedTextSection::Ptr create(const Color& foreColor, TextStyle textStyle)
        { return std::make_shared<FormattedTextSection>(foreColor, textStyle); }


    public:
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the text start position within the content origin data element, that is represented by this text element
        ///
        /// @param startInContentOrigin  The new text start position within the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setStartInContentOrigin(size_t startInContentOrigin)
        { m_startInContentOrigin = startInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text start position within the content origin data element, that is represented by this text element
        ///
        /// @return The text start position within the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t getStartInContentOrigin() const
        { return m_startInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the text length within the content origin data element, that is represented by this text element
        ///
        /// @param lengthInContentOrigin  The new text length within the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setLengthInContentOrigin(size_t lengthInContentOrigin)
        { m_lengthInContentOrigin = lengthInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text length within the content origin data element, that is represented by this text element
        ///
        /// @return The text length the content origin data element
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t getLengthInContentOrigin() const
        { return m_lengthInContentOrigin; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new text color of this text section
        ///
        /// @param color  The new text color of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setColor(Color color)
        { m_color = color; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text color of this text section
        ///
        /// @return The text color of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Color getColor() const
        { return m_color; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new character size of this text section
        ///
        /// @param height  The new character size of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRenderHeight(float height)
        { m_renderArea.height = height; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the character size of this text section
        ///
        /// @return The character size of this text section. Default is 16
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        unsigned int getCharacterSizeAsInt() const
        { return static_cast<unsigned int>(m_renderArea.height + 0.49f); }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new run length of this text section
        ///
        /// @param runLength  The new run length of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setRunLength(float runLength)
        { m_renderArea.width = runLength; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the run length of this text section
        ///
        /// @return The run length of this text section. Default is 16
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline float getRunLength() const
        { return m_renderArea.width; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new font of this text section
        ///
        /// @param font  The new font of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setFont(const Font& font)
        { m_font = font; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the font of this text section
        ///
        /// @return The font of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline Font& getFont() { return m_font; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new text of this text section
        ///
        /// @param string  The new text of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setString(const String& string)
        { m_string = string; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text of this text section
        ///
        /// @return The text of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline String& getString()
        { return m_string; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Sets the new text style of this text section
        ///
        /// The possible styles can be found in the tgui::TextStyle::Style enum.
        /// You can also pass a combination of multiple styles, for example tgui::TextStyle::Bold | tgui::TextStyle::Italic.
        /// The default style is tgui::TextStyle::Regular.
        ///
        /// @param style  The new text style of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void setStyle(TextStyle style)
        { m_style = style; }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Gets the text style of this text section
        ///
        /// @return The text style of this text section
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline TextStyle getStyle() const
        { return m_style; }

    protected:
        size_t            m_startInContentOrigin;  //!< The text start position within the content origin data element
        size_t            m_lengthInContentOrigin; //!< The text length within the content origin data element
        Color             m_color;                 //!< The text color
        Font              m_font;                  //!< The text font
        String            m_string;                //!< The text string
        TextStyle         m_style;                 //!< The text style
    };
}

#endif // TGUI_FORMATTED_ELEMENTS_HPP
